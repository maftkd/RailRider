using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using SplineMesh;

public class RailGenerator : MonoBehaviour
{
	CubicBezierPath _path;
	List<Vector3> _knots = new List<Vector3>();
	//temp code for debugging
	List<Vector3> _turnCenters = new List<Vector3>();
	LineRenderer _line;
	public Material _lineMat;
	float _nodeDist = 16f;
	int _lineResolution = 10;
	float _moveSpeed=0.3f;
	CurveSample _curSplineSample;
	Transform _railTracker;
	float _balanceSpeed = 100;
	
	// Start is called before the first frame update
	void Start()
	{
		//configure line renderer
		if(GetComponent<LineRenderer>()==null)
			_line = gameObject.AddComponent(typeof(LineRenderer)) as LineRenderer;
		else
			_line = GetComponent<LineRenderer>();
		_line.widthMultiplier=0.1f;
		_line.material=_lineMat;
		
		//configure railTracker
		_railTracker=transform.GetChild(0);

		//ok so lets try adding some nodes
		_knots.Add(Vector3.zero);
		_knots.Add(Vector3.forward*_nodeDist);

		//here we create a zig-zag with 10 cycles
		/*for(int i=0; i<10; i++){
			_knots.Add(_knots[_knots.Count-1]+new Vector3(.447f,0,.894f)*_nodeDist);
			_knots.Add(_knots[_knots.Count-1]+new Vector3(-.447f,0,.894f)*_nodeDist);
		}*/
		AddCurve(_nodeDist*2,3,false);
		AddCurve(_nodeDist*2,3,true);
		//instantiate our cubic bezier path
		_path = new CubicBezierPath(_knots.ToArray());	
		
		//create a line to render the spline
		_line.positionCount=_lineResolution*(_path.GetNumCurveSegments());
		for(int i=0; i<_line.positionCount; i++){
			float t = i/(float)_lineResolution;
			_line.SetPosition(i,_path.GetPoint(t));
		}
		//start test
		StartCoroutine(TestRide());
		
	}
	
	IEnumerator TestRide(){
		float t=0;
		float balance=0;
		while(t<_knots.Count-1){
			balance+=Input.GetAxis("Horizontal")*Time.deltaTime*_balanceSpeed;
			if(Input.GetMouseButton(0))
			{
				Vector2 curPos = Input.mousePosition;
				if(curPos.x>Screen.width*.6f)
					balance+=Time.deltaTime*_balanceSpeed;
				else if(curPos.x<Screen.width*.4f)
					balance-=Time.deltaTime*_balanceSpeed;
			}
			_railTracker.position = _path.GetPoint(t);
			_railTracker.forward = _path.GetTangent(t);
			Vector3 localEuler = _railTracker.localEulerAngles;
			localEuler.z = -balance;
			_railTracker.localEulerAngles=localEuler;
			t+=Time.deltaTime*_moveSpeed;
			yield return null;
		}
	}

	void AddCurve(float radius, int sectors, bool toRight){
		//get the current rail head
		//get the center of the circle position
		//get circumference c=pi*2*r
		//get sectorfraction = circumference/_nodeDist	
		//get sectorFractionAngle = sectorFraction*2*PI
		float c = Mathf.PI*2*radius;
		float secFrac = _nodeDist/c;
		float secAngle = secFrac*Mathf.PI*2;
		secAngle = toRight ? secAngle*-1f : secAngle;
		Debug.Log("sector angle: "+secAngle);
		//temp code - hardcoding
		Vector3 turnCenter = _knots[_knots.Count-1];
		Vector3 tan = turnCenter-_knots[_knots.Count-2];
		tan.Normalize();
		Debug.Log("tan: "+tan);
		Vector3 right = Vector3.Cross(Vector3.up,tan);
		right = toRight? right : right*-1f;
		Debug.Log("right: "+right);
		float angleOffset = Mathf.Atan2(-right.z,-right.x);
		Debug.Log("angle offset: "+angleOffset);
		turnCenter+=right*radius;
		_turnCenters.Add(turnCenter);
		for(int i=1; i<=sectors; i++){
			Vector3 pos;
			float ang = angleOffset+secAngle*i;
			if(toRight)
				pos = new Vector3(turnCenter.x-Mathf.Cos(ang)*radius,0,turnCenter.z+Mathf.Sin(ang)*radius);
			else
				pos = new Vector3(turnCenter.x+Mathf.Cos(ang)*radius,0,turnCenter.z+Mathf.Sin(ang)*radius);
			_knots.Add(pos);
		}
	}

	// Update is called once per frame
	void Update()
	{

	}

	void OnDrawGizmos(){
		if(_line!=null)
		{
			Gizmos.color = Color.green;
			for(int i=0; i<_line.positionCount; i++){
				Gizmos.DrawSphere(_line.GetPosition(i),.1f);
			}
		}
		if(_knots!=null)
		{
			Gizmos.color = Color.red;
			for(int i=0; i<_knots.Count; i++){
				Gizmos.DrawSphere(_knots[i],.5f);
			}
		}
		if(_turnCenters!=null){
			Gizmos.color = Color.blue;
			for(int i=0; i<_turnCenters.Count; i++){
				Gizmos.DrawSphere(_turnCenters[i],1f);
			}
		}
	}
}
